# NodeJS

不是一门新的语言，是js语法格式，js本身并不能执行，需要借助宿主环境。浏览器就是js的宿主环境，NodeJs提

供了js执行的环境。

NodeJs搭建web服务器

官网：https://nodejs.org/en/，这里我们切换为最新的14.15.1

文档地址：https://nodejs.org/docs/latest-v10.x/api/

中文文档：http://nodejs.cn/api/



## 特点

单线程：

​	整个程序只有一个线程执行 （同一时间只能做一件事情）

非阻塞I/O

I/O： Input/Output

从磁盘向内存输入内容，叫做Input

从内存向磁盘输出内容，叫做Output

非阻塞I/O:

​	当js线程执行的时候，如果遇到非阻塞I/O任务，此时只是开启任务，立即执行下一条任务

阻塞I/O:

​	当js线程执行的时候，如果遇到阻塞I/O任务，此时开启任务并等待任务完之后，才会去执行下一个任务



## 事件驱动与使用场景

事件驱动

​	当js线程执行的时候，由于是非阻塞的，线程不会等待任务执行完毕，后面的任务怎么执行，此时会一个事件，

由该事件将后续的任务重新放回js执行队列中(nodejs循环队列)



使用场景

​	nodejs搭建的服务器，适合高并发、异步多，但不适合复杂的计算，计算时同步的，会造成线程阻塞。



 例：

​	去火车站买票，只有一个售卖窗口（单线程），大家为了能够正常购票，排队购票(执行队列)，有一位美女，购

票但是忘记带身份证（I/O阻塞），喊她二大姑给他送（需要时间），管理人员（事件驱动）让她去第二位排队或

者去最后排队(循环队列)。



##  运行nodejs文件

1、去到对应的server.js文件所在目录  切换目录使用 cd

2、window如何切换盘符:  d:

node 文件名（js文件）



## 模块化

CMD： seajs

暴露的变量： seajs和define

暴露接口： 

​	module.exports  exports  return

引用模块：

​	require

AMD: requirejs

暴露的变量: requirejs(require) define

暴露接口：

​	module.exports  exports  return 

​	推荐使用 return

nodejs中

引用模块：

​	require

暴露接口：	

​	module.exports

​	exports

​	不支持return



## 模块的分类

自定义模块和系统核心模块（内置模块）， 一个js文件默认就为一个模块

内置模块：我们要学习的模块：
			path、http、https、fs、url、querystring



## 引入第三方模块

执行代码：（错误示范）

```js
var res = require('demo');
console.log(res);
```





这里在引入自定义的模块的时候，相对路径的 ./ 不能省略
正确的引用方式:

```js
var res = require('./demo');
console.log(res);
```





## 第三方模块文件 node_modules文件夹

如果想让第三方的模块像内置模块一样引入，在引用的js文件的当前文件夹或当前文件夹的父级文件夹下创建node_modules文件夹，将要引入的模块文件放入其中。(类比于作用域，最顶层为所在盘符)



## HTTP模块

该模块用于搭建一个服务器

引入http模块

> demo:

```js
    // 引入http模块
    var http = require('http');	
    // 创建服务器对象
    var server = http.createServer(function() {
        console.log('前端发送了请求');
        // console.log(arguments.length);
    })
    // 设置监听端口号
    server.listen(3000);
```



### 处理函数

http.createServer方法用于创建一个服务器对象
使用方式:http.createServer(handle)， 返回值为HTTP服务器对象
handle: 处理函数

函数中有两个参数:
- req: request 前端本次请求的对象
  - url：表示本次请求的路径, 包含的是path部分和query部分
  - method: 本次请求的方式（是大写的）
  - headers： 请求头信息
- res: response 响应对象，用于返回的内容
  - write： 返回内容，但是不会断开连接
  - end: 返回内容，返回之后会断开连接，接收的数据类型只能是字符串和buffer数据
  - setHeader: 用于设置响应头
  - writeHeader: 跟setHeader类似

- writeHeader和setHeader的区别：
      writeHeader可以设置http返回状态码，多个http响应头。
      但是setHeader只针对单一属性的设置。
      var server = http.createServer(function(req, res) {
      	// req 请求对象    
          // res 响应对象
      })
  - req.method: 请求方式
  - req.url：请求路径
  - res.end(): 响应的内容
  - res.setHeader(): 设置相应头信息



### 监听方法

server.listen(port，ip， callBack)

​		port: 监听端口号

​		ip: 指明ip

​		callBack: 回调函数

执行代码：

```js
// 引用http模块
var http = require('http');
// http是一个对象
// console.log(http);
// 创建http服务
var server = http.createServer(function(req, res) {
    // console.log(req, res);
    // req 请求对象
    // console.log(req);
    // res 相应信息
    // 请求方式
    console.log(req.method);
    // 请求URL地址

	console.log(req.url);
	// console.log(111);
    // 设置响应头信息
    res.setHeader('content-type', 'text/html;charset=utf-8');
    // 返回一条信息： 设置返回的内容
    // res.end('hello world');
    res.end("<b>我爱你中国</b>");
}).listen(3000, function() {
    console.log("后台服务器开始运行了");
});
// 设置监听的端口
// server.listen(3000);
```







## FS模块

file system 文件系统 操作文件及文件夹

引入fs模块

```js
var fs = require('fs');
```



### 创建文件

fs.appendfile(path, data, callBack)
- path: 生成文件的路径，如果文件存在则在原有的内容之后追加内容
- data：要写入的数据
- callBack：执行完毕之后的回调函数
- 回调函数的实参为操作的结果
    - 成功：null
    - 失败：错误对象

执行代码：

```js
// 引入fs模块
var fs = require('fs');
// console.log(fs);
// 创建文件
fs.appendFile('./xxoo/iloveyou', 'i love you forever', function(res) {
    // console.log(arguments);
    /* 
        res返回值的情况：
            成功：null
            失败：对象
    */
    console.log(res);
});
```



### 删除文件

fs.unlink（path, callBack）

- path：文件路径
- callBack： 回调函数



执行代码：

```JS
 // 引入fs模块
    var fs = require('fs');
    // 删除文件                                             
    fs.unlink('./iloveyou', function(res) {
        // 结果同之前的一样   
        console.log(res);
        // console.log(arguments);
    });

```



### 修改文件（文件名、剪切文件、修改文件夹、剪切文件夹）

fs.rename（oldpath，newpath，callBack）

- oldpath:原来的路径
- newpath:新的路径
- callBack：回调函数



执行代码：

```JS
// 引入fs模块
var fs = require('fs');
// 删除文件
fs.rename('oldname', 'newname', function(res) {
    // 结果同之前的一样
    console.log(res);
    // console.log(arguments);
});

```



### 读取文件

fs.readFile(path, callBack)
- path：文件的路径
- callBack：回调函数
  - 成功时：传入两个参数，第一个参数为null，第二个参数为读取到的内容
  - 失败时：只有一个参数，为错误信息的对象

执行代码:

```JS
// 引用fs模块
var fs = require('fs');
// 调用读取文件
fs.readFile('./newname', function(res, arr) {
	// res和之前的结果相同
	// arr成功时为读取到的内容， 失败时不存在
	console.log(res);
	console.log(arr);
	// console.log(arguments);
})

```



### 创建文件夹

fs.mkdir(path, callBack)
- path: 文件夹路径
- callBack：回调函数
  - 成功：null
  - 失败：错误信息对象

执行代码：

```JS
// 引用fs模块
var fs = require('fs');
// 创建目录
fs.mkdir('./xxoo', function(res) {
    // console.log(arguments);
    console.log(res);
});

```



### 读取文件夹

fs.readdir(path, callBack)

- path:读取文件夹的路径
- callBack：回调函数
  - 成功: 第一个实参为null，第二个实参为数组，数组元素为文件夹内的文件和文件夹



### 删除文件夹

fs.rmdir(path, callBack)

执行代码：

```JS
// 引用fs模块
var fs = require('fs');
// 删除目录
fs.rmdir('./003', function(res) {
    console.log(arguments);
    // console.log(res);
});
    
```



### 判断文件夹的状态

fs.stat(path, callBack)

- path: 文件（夹）路径
- callBack: 回调函数
  - 失败： 错误对象
  - 成功：第一个参数为null, 第二个参数为文件对象，可以通过调用对象的方法实现具体其他操作

用来判断文件类型



删除非空目录

try {

​	监测的代码

} cath(e) {

​	e为错误对象

}

不会影响后续代码的执行



## 服务器

服务器的分类
    按照请求的资源类型进行的分类，分为两类
- 静态服务器：  静态网页	请求的资源为html、css、js、图片等
- 动态服务器： 动态网站 登陆、注册等

搭建静态服务器
目标： 浏览器请求那个文件，将对应文件的内容返给浏览器

思路：
- 获得请求文件的路径
- 根据路径找到对应的文件，有则返回没有则给出提示
- 设置对应的头信息
    - 头信息：文件的后缀----> MIME类型
- 当访问的文件夹的时候，让其默认访问该文件夹下的index.html



## 路径问题

根：
- html的根：server.js所在的目录
- node的根： server.js所在的盘符

客户端：
    绝对路径：
    	详细： http://www.baidu.com/1.jpg
    	省略域名： /1.jpg
    相对路径： 
    	html: html文件
    	js:引入他的html文件
    	css:css文件

服务器：
    绝对路径： 
    	/ ：window下，server.js所在盘符
    相对路径： 当前文件



## url模块

引用内置的url模块

```JS
var url = require('url');
```



### parse

将获得的url字符串解析成url对象

parse(str, bool)
- str: 访问的地址
- bool： 是否将查询字符串转为对象的格式，默认值为false

执行代码：

```JS
// 引入url模块
var url = require('url');
// 访问地址
var str = '/web/index.html?name=1';
// parse: 可以将url字符串解析成对象
var url_obj = url.parse(str, true);
console.log(url_obj);

```

### format

 将url_obj对象转为url字符串，是parse的反向操作

执行代码：

```JS
// format: 将url_obj对象转为字符串
    var newstr = url.format(url_obj);
    console.log(newstr);

```



## MIME类型和path模块

MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。

path模块
parse(path)： 将路径解析为对象

join（oldpath, newpath）： 将路径进行拼接
oldpath: 原来的路径
newpath: 目标路径

将原来的路径作为参考，和目标路径进行拼接，形成一个新的路径



## 接口

网站中有一些需求直接在服务器端处理完毕，返回的只是一个结果，而不是请求静态资源。比如注册，登陆等

并不需要返回静态资源，返回一个结果。

执行代码：

```JS
// 判断用户是否在执行登陆操作
    if (url_str == '/dologin') {
        // 设置响应头
        res.setHeader('content-type', 'text/plain;charset=utf-8');
        // 响应信息
        res.end(Math.random() > 0.5 ? '登陆成功': '登陆失败');
    }

```



## querystring模块

模块中的parse方法：

parse(querystr, bigSplit, smallSplit)
        querystr: query字符串，查询字符串
        bigSplit: 分隔键值对的字符串，默认值为&
        smallSplit: 分隔键值对中的键和值的字符串，默认为=



## nodejs处理get

get请求数据是在query字符串中，获得方式

- 通过req对象中的url属性获得请求的路径
- 通过url模块中的parse方法将url字符串解析为对象，注意第二个参数必须为true，保证query字符串解析为对象
- 可以通过query对象获得传输过来的信息



## nodejs处理post

post请求和get请求的区别：

​    **大小**：post传输的数据没有大小限制，get是有大小限制的

​    **方式**：post通过请求体传输数据，get通过url传输数据

nodejs如何获得post传输的数据,通过两个事件来获得传输的数据分别为data和end事件

​    data:当post请求触发的时候，就会触发该事件，该事件会自动传入一个实参，实参为传输的数据 

​    end:当所有数据接收完成会触发该事件

上面的两个事件需要通过请求对象req进行绑定，data事件是可以触发多次的，而end事件只触发一次。

**post获得数据**

- 绑定data事件和end事件
- 在end事件中获得query字符串，该字符串为提交的数据
- 调用querystring模块的parse方法将字符串解析为对象
    POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。
    比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。



## AJAX

在早期浏览器只是为了渲染页面，但是随着发展，js出现单独的解析器，js的功能变得越来越丰富。现在学习的所有的请求有一个共同点都会进行页面的刷新，但是互联网现在更多了为了提升用户的体验，使用了很多的无刷新操作，京东当滚动条下拉至底端的时候，会自动增加新的内容，这些操作都是AJAX实现。

AJAX全称： Asynchronous JavaScript And XML   异步的js和xml

目标： 实现无刷新的数据请求
js实现请求，xml作为数据的传输的格式，现在不使用xml
取而代之的是JSON



### AJAX的使用

在高级浏览器和IE8支持XMLHttpRequest构造函数，低版本支持ActiveXObject（‘Microsoft.XMLHTTP’）
产生一个xhr对象，用于发送请求和接收数据

重要的属性和方法：
onreadystatechange: 该方法用于监听xhr对象的状态码，当状态码发生改变的时候会触发该事件
readyState: xhr对象的状态码 默认值为0
- 0： 表示未初始化
- 1：表示初始化，调用了open方法
- 2：已经接受到了响应头信息，服务器对请求已经处理
- 3：接收到了一部分相应数据
- 4：响应数据全部接收完毕
status: HTTP请求的状态码
responseText: 响应的内容
open方法: 用于建立tcp链接，发送http请求 
send方法：用来发送请求的内容



### 浏览器的兼容处理

1、产生xhr对象,能力检测，兼容浏览器

```JS
if (window.XMLHttpRequest) {
    // 高级浏览器
    var xhr = new XMLHttpRequest();
} else if (window.ActiveXObject('Microsoft.XMLHTTP')) {
    // 低版本IE浏览器
    var xhr = new ActiveXObject('Microsoft.XMLHTTP');
} else {
    throw new Error('请升级浏览器');
}
```



监测事件：

```JS
    // 2、监听事件
    xhr.onreadystatechange = function() {
        // 获得xhr对象的状态
        console.log(xhr.readyState);
    }
```



### 发送请求

发送请求：
xhr.open(method, url, bool)
method: 请求方式  get或者post
url: 你要请求的地址
bool: 是否进行异步请求 默认值为false 表示同步， true代表使用异步请求
    // 3、建立tcp链接，发送请求
    xhr.open('get', '/register', true); 

发送数据：
    // 4、发送数据
    xhr.send();

get请求
get请求服务器端设置:pathname == '/register' && method == 'get'

ajax的post请求：
服务器端代码



### jquery中的ajax

get请求
$.get(url, data, callBack, dataType);
    **url:**待载入页面的URL地址
    **data**:待发送 Key/value 参数。<b style="color:red;">可以使用对象还可以是query字符串</b>
    **callBack**:载入成功时回调函数。回调函数有一个参数为请求回来的数据。
    **dataType**:将返回内容进行解析的格式，xml, html, script, json, text, _default。

post请求
$.post(url, data, callBack, dataType);
    **url:**待载入页面的URL地址
    **data**:待发送 Key/value 参数。<b style="color:red;">可以使用对象还可以是query字符串</b>
    **callBack**:载入成功时回调函数。回调函数有一个参数为请求回来的数据。
    **dataType**:将返回内容进行解析的格式，xml, html, script, json, text, _default。



### ajax通用方式

$.ajax(options);
options是一个配置的对象

url: 请求的地址
type: 请求方式
data：请求的数据
dataType： 返回数据类型，如果返回json字符串，你写json自动转为json对象
success: 成功时执行的回调函数
error： 失败时执行的回调函数
complete: 完成时执行的函数
processData： 布尔值默认为true，表示jquery对数据进行序列化操作
contentType: 布尔值默认值为true，表示让jquery进行设置，jquery默认将content-type设置为application/x-www-form-urlencoded 



## 表单的序列化

ajax的好处，可以实现无刷新请求，不好的地方每一次传输数据都需要手动填写
表单获取的快捷方式： document.forms 获得是一个类数组对象
获得指定的表单： document.forms[index]
jquery中表单的系列化： 表单.serialize();

执行代码：

```JS
	// 使用jquery中的表单序列化
    console.log($(document.forms[0]).serialize());
```



## 转码与解码

编码：encodeURIComponent

解码：decodeURIComponent



执行代码：

```js
xhr.open('get', '/register?username=我爱#你中国&pwd=123', true);
```



在ajax请求的时候传输的数据都应该使用encodeURIComponent进行编码

实现表单的序列化

获得表单：document.forms[index]

获得表单的子元素： form.elements



## 历史事件对象

在h5中提供了history对象，可以用来管理历史记录
前进: forward
后退：back
前进后退： go

添加历史记录： pushState(data, title, url)
    data:传输的数据
    title：设置网页的标题（一般不使用）
    url: 添加的地址

替换历史记录： replaceState(data, title, url)
    data:传输的数据
    title：设置网页的标题（一般不使用）
    url: 替换的地址

检测事件：
    window.onpopstate事件



## FormData构造函数

序列化
FormData是ajax发展到2.0版本新增的构造函数，用于快速将表单中的数据进行序列化

使用方式：
    fd = new FormData(form) 
    form：你要序列化的表单
    
    传参： 直接将表单中的数据序列化，不传入任何的参数，也会得到一个对象fd， 可以通过fd中的方法向其中添加数据。

表单被序列化之后的数据不能直接查看，需要使用forEach



## forEach 

跟数组的forEach及其类似

```js
fd.forEach(function(value, key, fd){
    value为值，key为键，fd为fd对象
})
```



## append  

该方法用于向序列化对象中添加数据
使用方式：

```js
fd.append(key, value)
	key: 键名
	value: 值
```


## delete

通过指定的键名删除指定的键值对

使用方式：

​    fd.delete(key) : key为要删除键值对的键



## get

通过指定的键名获得对应键值对的值（多个值只获得第一个）

使用方式：

​    fd.get(key)

通过指定的键名获得对应键值对的值（获得对应键的所有值）

使用方式：

​    fd.getAll(key)



## has

用于检测序列化的数据对象中是否含有指定键

使用方式：

​    fd.has(key) 

返回值为bool类型，存在为true不存在为false



## set

可以用于修改键值对

使用方式：

​    fd.set(key, value);

存在则修改，没有则添加



## 图片预览

实现上传图片的时候，可以预览图片

FileReader（H5）

​	是一个构造函数，产生一个对象，用于读取上传文件的数据，得到的是一个base64资源

使用方式:

```js
var fr = new FileReader();
```



**文件上传框的属性**：

​    multiple： 可以设置多个文件上传

​    accept ：MIME类型，筛选的过程

**知识点**：

- 获得文件的上传信息 ： file对象.files[index]

- 读取数据： fr.readAsDataURL(上传信息对象) 读取的过程为一个异步的过程

- 读取完成： fr.onload事件

- 获取到的结果为base64 ，直接将img的src指向获得的base64资源即可
 
 
 
 window.URL.createObjectURL(file)



## 轮询

轮询就是前端通过ajax请求后端，周期性的请求。

原因就是http协议是一个无状态的协议，用户请求之后，服务器给出响应，这个链接就会断开。

聊天室，需要有内容主动刷新的过程，使用周期执行函数，每隔一段时间向服务器发送一次请求，看是否有新的数

据产生，如果有则请求回来。



## 域与跨域

域

**域**： 域名

文件请求的过程中，域名最终是要解析为ip地址(DNS)



跨域

​	**说明**：

​		发送请求到服务器A，服务器A给出了响应的页面，当页面渲染完毕，通过该页面向服务器B发送请求，这个请求称之为跨域请求



**跨域请求的条件**：

​	协议、域名、端口号不同	

只要满足上诉三个条件中的一个，都可以判定为跨域请求



**同源策略**

​	浏览器有一个同源策略，是不允许跨域请求(ajax)

​	但是，静态资源的请求不受同源策略的影响

​	在html页面引入其他网站的css、js、以及图片等等



## JSONP

JSONP: json + padding

jsonp是实现跨域请求的一种方法，json是一种数据格式

**跨域请求的实现**：

​	利用静态资源的请求不受同源策略的影响，比如img, srcipt标签都是可以的。使用的是script标签，原因script

引用的资源在引入回来之后会被当做代码来执行。做法，将script标签的scr属性指向请求的地址。



## 实现jsonp跨域的步骤

1、使用script标签的scr属性发送请求

2、在服务器端设置指定类型的字符串， 返回的字符串需要拼接为函数调用的形式，真正传输的数据作为函数调用

的实参

3、在发送请求的script标签之前声明对应的函数，并设置对应的形参，用于接收服务器返回的数据



**jquery的跨域**

设置请求地址：http://localhost:3000/getMsg

请求头中的地址：http://localhost:3000/getMsg?callback=jQuery112302632264233457333_1581129662432&_=1581129662433





## https服务器

http是一个无状态的协议，在请求的过程中，只要请求正确不会验证请求的发起者，存在一些安全的风险，如果出

现了数据拦截，个人信息存在安全隐患。https协议等价于 http + ssl，在https请求发送的时候就会进行验证，更

加安全。

想搭建https服务器需要证书

http://localhost:3000/index.html
https://localhost:3000/index.html

通过git的openssl生成证书文件





## Cookie

​    cookie是http协议中请求头的一部分，主要用来验证用户的信息，cookie是由服务器进行设置的，存储在客户

端，cookie是有大小的限制，最大不能超过4kb。



**cookie实现登陆的原理**

​    http是一个无状态的协议，理论上不能够保持登陆的状态。当用户输入账号和密码之后，服务器就收到该信息，

并进行验证，如果用户通过验证，服务器会在响应头中通过set-cookie字段让客户端设置cookie，cookie当中就可

以存放登陆的相关信息，浏览器接收到响应之后，会根据set-cookie字段的要求，在客户端存储 相应的内容。

cookie有一个特点，每当你访问对应的域名的时候，都会自动的将网站的cookie携带过去，服务器就可以根据

cookie字段中的设置，来判断该用户是谁，是否进行登录了等相关信息。 



## session

session实现的功能和cookie是一样的，是cookie的加强版本，session在默认的情况下，依赖于cookie来实现，

cookie将信息存储在客户端，session将信息存储在服务器端。cookie是有大小限制的，session的大小取决于服务

器的大小。



当服务器验证用户的信息通过的时候，创建对应的session文件，将session文件的标识（session_id）通过响应头

的set-cookie传给客户端，客户端拥有了开启session文件的一个号码牌，以后每次客户端请求服务器的时候都会

将session_id传递给服务器，服务器就可以根据session_id来读取指定session文件，来分辨用户的信息。



## cookie和session对比

办会员来说：

cookie是一张卡片，上面有你的头像，用户信息，以及公司的公章，去到公司使用的时候，带上会员卡-----cookie

session是一张卡片， 上面只是一串数字，去到公司使用的时候，读取卡片就可以获得用户的信息 ---- session



## token

token表示凭证、令牌

是由服务器来生成的，跟http协议没有任何的关系



**登陆实现**

当用户通过ajax或者表单发送请求的时候，请求到达服务器，服务器处理之后，会将用户的信息与秘钥一起生成一

个随机的字符串并签名,即是生成一个token字符串。用户所有的信息都在token字符串中，之后服务器不在保存用

户的信息，浏览器请求断开之后，记录这个token字符串，下次请求的时候必须携带该字符串，表单的隐藏域就可

以来进行传输token，服务器在判断用户请求的时候，就会判断用户的token是否合法，合法就处理，不合法直接

拒绝。可以根据token字符串判断用户的信息和登陆状态等。



## nodejs中的变量

使用nodejs的时候，没有书写任何的变量，但是可以调用http、fs、https、require、exports、module等等，为

什么这些可以使用？

其实，当我们执行nodejs命令的时候，并没有直接执行js文件，而是对js文件进行打包处理，打包成了模块



# 框架设计

## 一、MVC设计模式

MVC的思想很简单，就是“分层”。

以前写代码，都是所有的代码放在一起。功能实现了，但是显得很臃肿。

MVC的分层：分成三层。

M：Model 模型层      负责存储和提供数据

V：View  视图层      负责渲染页面

C：Controller 控制器层  负责实现逻辑交互



MVC的功能：

C是核心，可以从M中获取数据、更新数据 可以更新视图

V可以从M中获取数据

M只负责存储和提供数据



## 二、MVVM

M：模型层 负责存储数据

V：视图层 负责渲染视图

VM：视图模型层 负责将模型层与数据层联系起来

MVVM最大的特点：双向绑定

双向绑定：

​	当视图发生变化，能够影响到模型层的数据

​	当模型层中的数据发生改变，会立即渲染视图视图



## 三、NPM

### 3.1 介绍

NPM:Nodejs Package Manager(第三方包管理器)

在Nodejs中的模块文件分为两类：

- 核心模块文件 这种文件可以直接使用
- 第三方模块文件  所谓第三方模块每一个程序员都可以自定义的文件

Node_modules文件夹：

​	该文件的作用是用于存储所有的第三方模块文件，在该文件中的所有第三方模块文件，当我们引入的时候就可以像引入核心模块文件那样引入

### 3.2 使用

官网：https://www.npmjs.com

如果想要使用npm应用程序

我们必须先下载

该程序已经在下载nodejs程序的时候默认下载了

#### 3.2.1 使用指令

npm install ModelName

​	该条指令可以将ModelName下载到你的电脑中

npm install ModelName1 ModelName2 ModelName3

​	该条指令可以将多个模块文件一起下载到你的电脑中

**注1：**

当我们使用Npm指令时候，会先在同级目录寻找node_modules文件夹，如果同级没有则去上一级中查找，如果上一级还没有则会到上上级...， 如果找到则直接下载到找到的node_module文件夹中，如果直到盘符根目录下还没有该文件，则会回到你调用的时候的目录去创建一个node_modules文件夹并下载

**注2：**

如果当前目录下存在一个package.json文件，则下载的模块文件不会继续往上找了，直接在当前层级中直接下载

 

**注3：**

如果在下载文件的时候，输入指令 npm install modelName --save 

则会将下载的模块文件存储在package.json文件中的dependencies中  ‘运行时候的模块’

 

如果在下载文件的时候，输入指令 npm install modelName --save-dev 

则会将下载的模块文件存储在package.json文件中的devDependencies中  ‘开发时候的模块’

#### 3.2.2 package.json

每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称/版本/许可证等元数据）。npm install 命令根据这个配置文件，自动下载所需要的模块，也就是配置项目所需的运行和开发环境。

#### 3.2.3 生成package.json文件

通过 npm init 指令即可生成该文件

根据提示信息输入完毕之后，会自动生成package.json文件

#### 3.2.4 下载别人的项目

指令：npm install

当我们写完一个项目的时候，可以将项目上传到git中，我们还可以下载别人的项目，但是项目可能需要依赖一些模块，此时我们就可以通过指令去下载package.json文件中的dependencies和devDependencies中所有依赖的模块，才能够启动一个项目